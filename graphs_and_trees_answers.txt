EXERCISES
1. What is a binary tree and what makes it unique to other trees?
A tree data structure in which each node has at the most two children, referred to as left child and right child. unique from other trees because it can only have two branches for every node

2. What is a heuristic?
An approximate solution when classic methods fail to find any exact solution/rule of thumb/best guess.

3. What is another problem besides the shortest-path problem that requires the use of heuristics?
Travelling sales person problem

4. What is the difference between a depth-first search and a breadth-first search?
BFS - visits nodes by level exploring every node first before moving on to the next level
DFS - explores as far as it can in a branch before going back for unexplored nodes

5. Explain in your own words what an undirected, a-cyclic, unweighted graph is.
It would just be a tree

6. What kind of graph is a binary search tree?
undirected acyclic graph

PROGRAMMING QUESTIONS
1. Given a Binary Search Tree and a value, write a function that checks to see whether the value exists within the tree.

Example: The value 10 exists in the tree. The value 23 does not exist in the tree.

class Node {
  constructor(data, left = null, right = null) {
    this.data = data;
    this.left = left;
    this.right = right;
  }
}

class BST {
  constructor() {
    this.root = null;
  }

  add(data) {
    const node = this.root;
    if(node === null) {
      this.root = new Node(data);
      return
    } else {
      //search function
      const searchTree = function(node) {
        if(data < node.data) {
          if(node.left === null) {
            node.left = new Node(data);
            return;
          } else if (node.left !== null) {
            return searchTree(node.left);
          }
        } else if (data > node.data) {
          if(node.right === null) {
            node.right = new Node(data);
            return;
          }else if(node.right !== null) {
            return searchTree(node.right);
          }
        } else {
          //data is equal and not added to tree
          return null;
        }
      };
      return searchTree(node);
    }
  }
  isPresent(data) {
  let current = this.root;
  while(current) {
    if(data === current.data) {
      return true;
    }
    if(data < current.data) {
      current = current.left;
    } else {
      current = current.right;
    }
  }
  return false;
}
}

const bst = new BST();

bst.add(4);
bst.add(2);
bst.add(6);
bst.add(1);
bst.add(3);
bst.add(5);
bst.add(10);
console.log(bst.isPresent(10));
console.log(bst.isPresent(23));

2. Given a Binary Search Tree and two nodes, n1 and n2, write a function that finds the distance between the two nodes.

Example: The distance between the nodes 4 and 10 is 4. The distance between the nodes 8 and 10 is 1. The distance between the nodes 1 and 14 is 4.